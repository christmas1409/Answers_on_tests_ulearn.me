Изучите код ниже:

class Sample1 {
    static void F() {
        i = 1;
    }
    static int i = 0;
}

1. Корректно ли использование поля класса ДО его определения как в примере выше? 1 из 1 балла
Да, корректно
Правильно!

Нет, это не скомпилируется
Глобальные переменные и методы могут объявляться в произвольном порядке

Это скомпилируется, но при выполнении метода F возникнет ошибка
Ошибки областей видимости как правило приводят к ошибкам именно на этапе компиляции

Локальные и глобальные переменные могут иметь одинаковые имена, а неоднозначности разрешаются в пользу локальных переменных. Область видимости какого-либо объекта почти всегда определяется фигурными скобками. Используя эти знания, изучите код ниже и ответьте на вопросы:

class Sample2 {
    static string who = "class";
 
    static void F() {
        string who = "F";
    }
    
    static void G() {
        F();
        Console.WriteLine(who);
    }
   
    static void H() {
        string who = "H";
        F();
        Console.Write(who);
    }
}

2. Что будет выведено на консоль при вызове метода G()? 1 из 1 балла
class
Правильно!

F
Это разные who, ведь они определены в разных фигурных скобках! Изменение локальной переменной метода F не приводит к изменению глобальной переменной

H
Выполнение программы даже не дошло до строки who=''H'', не говоря уж о том, что в этой строке присваивается другая переменная

Ничего. Будет ошибка
Ошибки не будет, локальные переменные могут иметь то же имя, что и глобальные

3. Что будет выведено при вызове метода H()? 1 из 1 балла
class
Здесь переменных уже три: локальная метода H, локальная метода F и глобальная. Выводится локальная.

F
Нет. В методе F присваивается значение его локальной переменной

H
Правильно!

Ничего. Будет ошибка
Локальные переменные разных методов могут иметь одинаковые имена.

class Sample3 {
    static string who = "class";
   
    static void Mixed() {
        Console.Write(who + " ");
        string who = "Mixed";
        Console.Write(who);
    }
}

4. Что будет выведено при вызове метода Mixed()? 1 из 1 балла
class class
class Mixed
Mixed Mixed
К моменту вызова первого Write значение Mixed еще не было присвоено ни одной переменной

Mixed class
Ничего. Будет ошибка компиляции
Правильно! Область видимости переменной — это все фигурные скобки, где она определена. Однако использовать переменную до ее объявления, естественно, нельзя. Чтобы вы не запутались в именах, компилятор считает эту ситуацию ошибкой компиляции

Локальные переменные и параметры метода с пересекающимися областями видимости не могут называться одинаково. Если это правило нарушается, то компиляция закончится с ошибкой. Например, если в методе F(int x) объявить локальную переменную x, то такой код не скомпилируется.

class Sample4 {
    void M1() {
        int i = 0;
        {
            int i = 1;
        }
    }
    void M2(int i) {
        int i = 0;
    }
    void M3() {
        // Фигурными скобками можно группировать операторы (правда почти никогда этого делать не стоит)
    // и каждая пара фигурных скобок создает свою область видимости.
        {
            int i = 0;
        }
        {
            int i = 1;
        }
    }
}

5. В каких методах компилятор сгенерирует ошибки компиляции? 1 из 1 балла
M1
Правильно! Область видимости первой переменной i пересекается с областью видимости второй переменной i. Компилятор этого не прощает.

M2
Правильно! Область видимости аргумента метода и локальной переменной совпадают. Компилятор этого не допускает.

M3
В методе M3 области видимости переменных i не пересекаются
