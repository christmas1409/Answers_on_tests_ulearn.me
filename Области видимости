Изучите код ниже:

class Sample1 {
    static void F() {
        i = 1;
    }
    static int i = 0;
}

1. Корректно ли использование поля класса ДО его определения как в примере выше? 1 из 1 балла
Да, корректно
Правильно!

Локальные и глобальные переменные могут иметь одинаковые имена, а неоднозначности разрешаются в пользу локальных переменных. Область видимости какого-либо объекта почти всегда определяется фигурными скобками. Используя эти знания, изучите код ниже и ответьте на вопросы:

class Sample2 {
    static string who = "class";
 
    static void F() {
        string who = "F";
    }
    
    static void G() {
        F();
        Console.WriteLine(who);
    }
   
    static void H() {
        string who = "H";
        F();
        Console.Write(who);
    }
}

2. Что будет выведено на консоль при вызове метода G()? 1 из 1 балла
class
Правильно!

3. Что будет выведено при вызове метода H()? 1 из 1 балла
H
Правильно!

class Sample3 {
    static string who = "class";
   
    static void Mixed() {
        Console.Write(who + " ");
        string who = "Mixed";
        Console.Write(who);
    }
}

4. Что будет выведено при вызове метода Mixed()? 1 из 1 балла

Mixed class
Ничего. Будет ошибка компиляции

Локальные переменные и параметры метода с пересекающимися областями видимости не могут называться одинаково. Если это правило нарушается, то компиляция закончится с ошибкой. Например, если в методе F(int x) объявить локальную переменную x, то такой код не скомпилируется.

class Sample4 {
    void M1() {
        int i = 0;
        {
            int i = 1;
        }
    }
    void M2(int i) {
        int i = 0;
    }
    void M3() {
        // Фигурными скобками можно группировать операторы (правда почти никогда этого делать не стоит)
    // и каждая пара фигурных скобок создает свою область видимости.
        {
            int i = 0;
        }
        {
            int i = 1;
        }
    }
}

5. В каких методах компилятор сгенерирует ошибки компиляции? 1 из 1 балла
M1
Правильно! Область видимости первой переменной i пересекается с областью видимости второй переменной i. Компилятор этого не прощает.

M2
Правильно! Область видимости аргумента метода и локальной переменной совпадают. Компилятор этого не допускает.
